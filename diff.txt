diff --git a/build.py b/build.py
index 3fd2ab2..81cc655 100755
--- a/build.py
+++ b/build.py
@@ -25,9 +25,12 @@ sys.path.insert(0,os.path.abspath("./tools"))
 
 import build_server
 import build_tools
+import time
 
-def main():
 
+def main():
+	build_server.printMajorHeader("Building")
+	print ( build_server.highlight( "Built on: ") + time.strftime("%c"))
 	os.chdir( "./server" )
 	build_server.main()
 	os.chdir( "../" )
diff --git a/server/source/server/socket/socket.cpp b/server/source/server/socket/socket.cpp
index b6e4393..aa9511b 100644
--- a/server/source/server/socket/socket.cpp
+++ b/server/source/server/socket/socket.cpp
@@ -9,9 +9,6 @@
 #include "source/data_types/socket_message.h"
 #include "source/logging/exception_handler.h"
 
-
-SocketInterface::~SocketInterface() = default;
-
 Socket::Socket(const ServerConfig &config, std::atomic<bool> * _shouldContinueRunning) : shouldContinueRunning(_shouldContinueRunning),
 									FDs( new SetOfFileDescriptors() ),
 									reader(  new SocketReader(FDs.get(), shouldContinueRunning) ),
diff --git a/server/source/server/socket/socket.h b/server/source/server/socket/socket.h
index 68d60f2..f9d4063 100644
--- a/server/source/server/socket/socket.h
+++ b/server/source/server/socket/socket.h
@@ -14,31 +14,43 @@ class SocketWriter;
 class SocketServerConnector;
 class ClientValidatorInterface;
 
-class SocketInterface{
+class SocketInterface
+{
 public:
-	virtual SocketMessage getNextMessage() =0;
-	virtual void setClientValidator(ClientValidatorInterface * validator) =0;
-	virtual void sendMessage(SocketMessage &message) =0;
-	virtual void disconnectClient(int FD) =0;
-	virtual void shutdown() =0;
-	virtual bool isRunning() =0;
-	virtual ~SocketInterface();
+	virtual SocketMessage getNextMessage() = 0;
+	virtual void setClientValidator(ClientValidatorInterface * validator) = 0;
+	virtual void sendMessage(SocketMessage &message) = 0;
+	virtual void disconnectClient(int FD) = 0;
+	virtual void shutdown() = 0;
+	virtual bool isRunning() = 0;
+	virtual ~SocketInterface() = default;
 protected:
 	SocketInterface() = default;
 };
 
-struct ServerConfig {
-	std::string port = std::string();
-	int64_t loopSpeed = 100;
-	int MAXEVENTS = 200;
-	size_t MaxReaderSocketBufferSize = 32760;
-	size_t MaxWebsocketReadBufferSize = 262144;
-	int maxWaitTime = 1000;
-	size_t maxHandshakeSize = 2048;
-	ServerConfig() {}
+struct ServerConfig
+{
+	/** the port to connect the websocket on **/
+	std::string port {std::string("443")};
+	int64_t loopSpeed {100};
+	/** the maximum number of messages to read from the kernel on each epoll **/
+	int maxEvents {200};
+	/** the size of the buffer used to store messages from a client **/
+	size_t MaxReaderSocketBufferSize {32760};
+	/** the size of the buffer used to store messages waiting to be sent to a client */
+	size_t MaxWebsocketReadBufferSize {262144};
+	/** the number of milliseconds that the server threads should hang during epoll calls if no messages are present */
+	int maxWaitTime {1000};
+	/** the maximum allowable size of a handshake message from a client */
+	size_t maxHandshakeSize {2048};
+	ServerConfig() = default;
 };
 
-class Socket : public SocketInterface{ ///class starts new threads to handle socket io and cleans up on destruction
+/**
+ * Class starts new threads to handle socket io and cleans up on destruction
+ */
+class Socket : public SocketInterface
+{
 
 public:
 	Socket(const ServerConfig &config, std::atomic<bool> * _shouldContinueRunning);
diff --git a/server/source/server/socket/websocket/websocket_client_validator.h b/server/source/server/socket/websocket/websocket_client_validator.h
index 2ad2022..42d9301 100644
--- a/server/source/server/socket/websocket/websocket_client_validator.h
+++ b/server/source/server/socket/websocket/websocket_client_validator.h
@@ -10,15 +10,15 @@ public:
 	bool areClientHeadersValid(ConnectionHeaders &headers) override
 	{
 		(void)headers;
-		//accept all traffic
-		return true;
+		//reject all traffic
+		return false;
 	}
 	bool isClientIPValid(std::string &IP, std::string &port) override
 	{
 		(void)IP;
 		(void)port;
-		//accept all traffic
-		return true;
+		//reject all traffic
+		return false;
 	}
 	~DefaultClientValidator() override = default;
 };
diff --git a/server/source/server/socket/websocket/websocket_message_processor.cpp b/server/source/server/socket/websocket/websocket_message_processor.cpp
index 2c47783..039ebf0 100755
--- a/server/source/server/socket/websocket/websocket_message_processor.cpp
+++ b/server/source/server/socket/websocket/websocket_message_processor.cpp
@@ -77,7 +77,7 @@ void WebsocketMessageProcessor::processSockMessage (ByteArray &in,  int FD)
 
 void WebsocketMessageProcessor::storePartialMessage(ByteArray &in, uint64_t start, int FD) {
 	ByteArray message;
-	size_t messageSize = in.size()-start;
+	size_t messageSize = in.size() - start;
 	message.resize(messageSize);
 	memcpy(&message[0], &in[start], messageSize);
 	ReadBuffers->addMessage(FD, message);
@@ -90,14 +90,14 @@ uint64_t WebsocketMessageProcessor::getNet64bit (uint8_t *in)
 	uint8_t out[8];
 	uint64_t rval;
 
-	out[0]= in[7];
-	out[1]= in[6];
-	out[2]= in[5];
-	out[3]= in[4];
-	out[4]= in[3];
-	out[5]= in[2];
-	out[6]= in[1];
-	out[7]= in[0];
+	out[0] = in[7];
+	out[1] = in[6];
+	out[2] = in[5];
+	out[3] = in[4];
+	out[4] = in[3];
+	out[5] = in[2];
+	out[6] = in[1];
+	out[7] = in[0];
 
 	auto temp = reinterpret_cast<uint64_t *>(out);
 	rval = *temp;
@@ -111,8 +111,8 @@ uint16_t WebsocketMessageProcessor::getNet16bit (uint8_t *in)
 	uint8_t out[2];
 	uint16_t rval;
 
-	out[0]= in[1];
-	out[1]= in[0];
+	out[0] = in[1];
+	out[1] = in[0];
 
 	auto temp = reinterpret_cast<uint16_t *>(out);
 	rval = *temp;
@@ -124,26 +124,26 @@ int64_t WebsocketMessageProcessor::getMessageSize (ByteArray &in, uint64_t &mess
 {
 	uint64_t size = in[start+1]^128;
 	if(size >= 128){
-		throw std::runtime_error(LOG_EXCEPTION("maskbit was not set on descriptor "+std::to_string(FD)+" start: "+std::to_string(start)+ \
-		" in.size(): "+std::to_string(in.size())+". First bit "+std::to_string(static_cast<unsigned int>( in[start] )) )); //maskbit was not set
+		throw std::runtime_error(LOG_EXCEPTION("maskbit was not set on descriptor " + std::to_string(FD) + " start: " + std::to_string(start) + \
+		" in.size(): " + std::to_string(in.size()) + ". First bit " + std::to_string(static_cast<unsigned int>( in[start] )) )); //maskbit was not set
 	}
-	messageStart = start+6; //start of mask start
+	messageStart = start + 6; //start of mask start
 	if(size == 126){
-		if(in.size()-start<134){//ByteArray too small to read any data (header+mask takes a min of 8. Message length is at least 126)
+		if(in.size() - start < 134){//ByteArray too small to read any data (header+mask takes a min of 8. Message length is at least 126)
 			return -1;
 		}
-		messageStart = start+8;
+		messageStart = start + 8;
 		size = getNet16bit(&in[start+2]);
 	}
 	else if (size == 127){
-		if(in.size()-start<65550){//ByteArray too small to read any data (header+mask takes a min of 14. Message length is at least 65536)
+		if(in.size() - start < 65550){//ByteArray too small to read any data (header+mask takes a min of 14. Message length is at least 65536)
 			return -1;
 		}
-		messageStart = start+14;
+		messageStart = start + 14;
 		size = getNet64bit(&in[start+2]);
 	}
-	if(size>MaxReadBufferSize){
-		throw std::runtime_error(LOG_EXCEPTION("Message too large on on descriptor "+std::to_string(FD)+".  Size: "+std::to_string(size) ));
+	if(size > MaxReadBufferSize){
+		throw std::runtime_error(LOG_EXCEPTION("Message too large on on descriptor " + std::to_string(FD) + ".  Size: " + std::to_string(size) ));
 	}
 	return static_cast<int64_t>(size);
 }
@@ -172,7 +172,7 @@ void WebsocketMessageProcessor::handleFragment (ByteArray &in, uint8_t opcode, i
 		ReadBuffers->addFracture(FD,in);
 	}
 	else{
-		throw std::runtime_error(LOG_EXCEPTION("bad Opcode "+std::to_string(static_cast<int>(opcode))+" on descriptor "+std::to_string(FD)));
+		throw std::runtime_error(LOG_EXCEPTION("bad Opcode " + std::to_string(static_cast<int>(opcode)) + " on descriptor " + std::to_string(FD)));
 	}
 }
 
@@ -207,11 +207,11 @@ void WebsocketMessageProcessor::unmask (ByteArray &in, ByteArray &out, uint64_t
 	//process the rest 64bits at a time
 	if(i < length) {
 		uint64_t endBytes = (length-i) % 32; //run untill there are less than 4 8byte numbers left
-		uint64_t length64 = length-endBytes;
+		uint64_t length64 = length - endBytes;
 		length64 /= 8; //convert length64 from number of bytes to number of 64bit ints
 
 		auto output64 = reinterpret_cast<uint64_t*>(&out[i+begin]);
-		uint64_t offset= i;
+		uint64_t offset = i;
 
 		uint64_t mask64 = 0;
 		auto tempMask = reinterpret_cast<uint8_t*>(&mask64);
@@ -226,9 +226,9 @@ void WebsocketMessageProcessor::unmask (ByteArray &in, ByteArray &out, uint64_t
 			output64[++i] ^= mask64;
 		}
 
-		offset += i*8; //unmask the last remaining bits
+		offset += i * 8; //unmask the last remaining bits
 		endBytes += offset;
-		for(i = offset; i<endBytes; i++) {
+		for(i = offset; i < endBytes; i++) {
 			out[i+begin] ^= mask[i % 4];
 		}
 	}
@@ -242,12 +242,12 @@ size_t WebsocketMessageProcessor::extractMessages (ByteArray &in, std::vector< B
 	out.reserve(10);			//we could calculate how many messages are in 'in' here and reserve the correct number but it would be slow. 10 should cover most cases.
 	out.emplace_back( ByteArray() ); //create first element.
 
-	size_t currentM =0;
-	uint64_t start =0;
-	uint64_t size =0;
-	uint64_t messageStart =0;
+	size_t currentM = 0;
+	uint64_t start = 0;
+	uint64_t size = 0;
+	uint64_t messageStart = 0;
 
-	while(size<(in.size()-(messageStart))){
+	while(size < (in.size() - messageStart)){
 		size_t outStart = out[currentM].size();
 
 		if(!ReadBuffers->messageIsEmpty(FD)){
@@ -258,7 +258,7 @@ size_t WebsocketMessageProcessor::extractMessages (ByteArray &in, std::vector< B
 			}
 		}
 
-		if(in.size()-start<6){ //ByteArray too small to read any data (header+mask takes a min size of 6. Control frame message may be of length 0)
+		if(in.size()-start < 6){ //ByteArray too small to read any data (header+mask takes a min size of 6. Control frame message may be of length 0)
 			storePartialMessage(in, start, FD);//add to buffer for processing
 			return currentM;
 		}
@@ -270,7 +270,7 @@ size_t WebsocketMessageProcessor::extractMessages (ByteArray &in, std::vector< B
 		}
 		size = static_cast<uint64_t> (messageSize);
 
-		if(size>(in.size()-(messageStart))){ //only received partial message;
+		if(size > (in.size()-(messageStart))){ //only received partial message;
 			storePartialMessage(in, start, FD);
 			ReadBuffers->setMessageSize(FD, size);
 			return currentM;
@@ -280,7 +280,7 @@ size_t WebsocketMessageProcessor::extractMessages (ByteArray &in, std::vector< B
 		types[currentM] = opcode;
 
 		unmask(in, out[currentM], messageStart, size);
-		if(in[start]<128){ //Fragmented message
+		if(in[start] < 128){ //Fragmented message
 			handleFragment(out[currentM], opcode, FD);
 		}
 
@@ -295,7 +295,7 @@ size_t WebsocketMessageProcessor::extractMessages (ByteArray &in, std::vector< B
 				return currentM; //don't process further messages
 			}
 		}
-		start = messageStart+size;
+		start = messageStart + size;
 	}
 	return currentM;
 }
diff --git a/server/source/server/socket/websocket/websocket_read_buffer.cpp b/server/source/server/socket/websocket/websocket_read_buffer.cpp
index ebe42f1..73de8b5 100755
--- a/server/source/server/socket/websocket/websocket_read_buffer.cpp
+++ b/server/source/server/socket/websocket/websocket_read_buffer.cpp
@@ -41,11 +41,11 @@ bool WebsocketReadBuffers::extractMessage(ByteArray &out, size_t position, int i
 	if(messageBuffer.count(index) != 0) {
 		PartialMessage& tempBuff = messageBuffer[index];
 		if(!tempBuff.buffer.empty()) {
-			if(out.size()+tempBuff.size() <= maxMessageSize) {
+			if(out.size() + tempBuff.size() <= maxMessageSize) {
 				if( tempBuff.expectedSize > static_cast<int64_t>(maxMessageSize) ) {
-					throw std::runtime_error(LOG_EXCEPTION("Message expected size too large. Expectedsize: "+std::to_string(tempBuff.expectedSize)));
+					throw std::runtime_error(LOG_EXCEPTION("Message expected size too large. Expectedsize: " + std::to_string(tempBuff.expectedSize)));
 				}
-				if( static_cast<int64_t>( out.size()+tempBuff.size() ) >= tempBuff.expectedSize ) {
+				if( static_cast<int64_t>( out.size() + tempBuff.size() ) >= tempBuff.expectedSize ) {
 					ByteArray message;
 					if(tempBuff.expectedSize > 0) {
 						message.reserve( static_cast<size_t>(tempBuff.expectedSize) );
@@ -56,12 +56,12 @@ bool WebsocketReadBuffers::extractMessage(ByteArray &out, size_t position, int i
 						memcpy( &message[messageSize], &element[0], element.size() );
 					}
 					messageBuffer.erase(index);
-					out.insert( out.begin()+static_cast<int64_t>(position), message.begin(), message.end() ); //add message buffer to out;
+					out.insert( out.begin() + static_cast<int64_t>(position), message.begin(), message.end() ); //add message buffer to out;
 					return true;
 				}
 			}
 			else {
-				throw std::runtime_error(LOG_EXCEPTION("Client sent too much data.  Size: "+std::to_string(out.size()+messageBuffer[index].size()) ));
+				throw std::runtime_error(LOG_EXCEPTION("Client sent too much data.  Size: " + std::to_string(out.size() + messageBuffer[index].size()) ));
 			}
 		}
 	}
diff --git a/server/source/server/socket/websocket/websocket_read_buffer.h b/server/source/server/socket/websocket/websocket_read_buffer.h
index 4624f8d..4bc66fc 100755
--- a/server/source/server/socket/websocket/websocket_read_buffer.h
+++ b/server/source/server/socket/websocket/websocket_read_buffer.h
@@ -41,7 +41,7 @@ protected:
 			totalSize += addSize;
 		}
 		void clear(){
-			buffer=std::vector< ByteArray >();
+			buffer = std::vector< ByteArray >();
 			totalSize = 0;
 			expectedSize = -1;
 		}
diff --git a/server/tests/source/server/socket/websocket/websocket_authenticator_test.cpp b/server/tests/source/server/socket/websocket/websocket_authenticator_test.cpp
index 3738ba3..8a41258 100755
--- a/server/tests/source/server/socket/websocket/websocket_authenticator_test.cpp
+++ b/server/tests/source/server/socket/websocket/websocket_authenticator_test.cpp
@@ -50,9 +50,34 @@ class AuthenticatorTestFactory{
 public:
 	MockSystemWrapper &systemWrap;
 	WebsocketAuthenticator WA;
+
+
+	class MyClientValidator : public ClientValidatorInterface
+	{
+	public:
+
+		bool areClientHeadersValid(ConnectionHeaders &headers) override
+		{
+			(void)headers;
+			//accept all connections
+			return true;
+		}
+		bool isClientIPValid(std::string &IP, std::string &port) override
+		{
+			(void)IP;
+			(void)port;
+			//accept all connections
+			return true;
+		}
+		~MyClientValidator() override = default;
+	};
+
+	MyClientValidator validator;
 	AuthenticatorTestFactory(SetOfFileDescriptors*FDs ):
 		systemWrap(MockSystemWrapper::getMockSystemInstance(true)), WA(FDs)
-	{}
+	{
+		WA.setClientValidator(&validator);
+	}
 };
 
 TEST(WebsocketAuthenticatorTest, WebsocketAuthenticator)
diff --git a/server/tests/source/server/socket/websocket/websocket_message_processor_test.cpp b/server/tests/source/server/socket/websocket/websocket_message_processor_test.cpp
index f9c42fa..17b0b9f 100755
--- a/server/tests/source/server/socket/websocket/websocket_message_processor_test.cpp
+++ b/server/tests/source/server/socket/websocket/websocket_message_processor_test.cpp
@@ -35,12 +35,21 @@ public:
 	using WebsocketMessageProcessor::getNet16bit;
 };
 
+//release build
+//Built on: Sat Aug 11 00:42:13 2018
+//extract processed at a rate of 2.90605e-06 Gb/s
+//extract processed 100MBs in 2.75288e+08 milliseconds
 
+//release build
+//Built on: Thu Aug 23 14:55:46 2018
+//extract processed at a rate of 2.17512e-06 Gb/s
+//extract processed 100MBs in 3.67796e+08 milliseconds
 
-/*void test_ExtractMessage_performance(){
+
+void test_ExtractMessage_performance(){
 	std::vector< ByteArray > splitMessage;
 	uint32_t mask = 3893384930;
-	size_t messageSize = 1000000;
+	size_t messageSize = 100000000;
 	profiling::PerformanceTimer timer;
 	{//build a vector of string fragments (splitMessage) simulating a long message retreived over multiple reads
 		std::string testString = generateTestString(messageSize);
@@ -52,13 +61,16 @@ public:
 		}
 	}
 
-	MockSystemWrapper systemWrap;
-	SetOfFileDescriptors FDs(&systemWrap);
+	// reset system state
+	MockSystemWrapper::resetState();
+
+	//MockSystemWrapper systemWrap;
+	SetOfFileDescriptors FDs;
 	FDs.addFD(1);
 	WebsocketMessageProcessorWrap processor(&FDs);
 
 	double totalTime = DBL_MAX;
-	int count = 10;
+	int count = 20;
 	while(--count){
 		std::vector< ByteArray > decoded;
 		std::vector<int> types;
@@ -75,7 +87,7 @@ public:
 }
 
 
-void test_Unmask_performance(){
+/*oid test_Unmask_performance(){
 	profiling::PerformanceTimer timer;
 	uint32_t mask = 3893384930;
 	size_t messageSize = 100000000;
diff --git a/tools/source/images/png.cpp b/tools/source/images/png.cpp
index 8830fc7..defca53 100644
--- a/tools/source/images/png.cpp
+++ b/tools/source/images/png.cpp
@@ -319,7 +319,8 @@ void compressBuffer(std::vector<uint8_t> &data){
 		throw std::runtime_error("zlib compress failed in PngImage::compress");
 		return;
 	}
-	compressed.resize(outputSize);//needed because compress shrinks outputSize
+	//needed because compress shrinks outputSize
+	compressed.resize(outputSize);
 	data = compressed;
 	return;
 }
