// list of comma separated files this test needs to be linked with; read by the build script
#define TEST_FILE_LINK_DEPENDENCIES "source/server/socket/websocket/websocket_authenticator.cpp, \
                                     source/server/socket/websocket/websocket_handshake.cpp, \
                                     source/data_types/byte_array.cpp, \
                                     source/server/socket/file_descriptor.cpp, \
                                     source/logging/exception_handler.cpp, \
                                     source/data_types/reader_writer_lockguard.cpp, \
                                     source/server/socket/set_of_file_descriptors.cpp"

#include "source/server/socket/websocket/websocket_authenticator.h"
#include "source/server/socket/websocket/websocket_client_validator_interface.h"
#include "source/server/socket/set_of_file_descriptors.h"
#include "source/data_types/byte_array.h"
#include "tests/test_lib/mocks_stubs/mock_system_wrapper.h"
#include "tests/test_lib/mocks_stubs/socket_test_helpers.h"
#include "tests/test.h"

// creates a typical websocket handshake request header from a browser
ByteArray createTestHandshakeRequestHeader(){
	ByteArray output;

	output.appendWithNoSize("GET /socket HTTP/1.1\r\n");
	output.appendWithNoSize("Host: localhost\r\n");
	output.appendWithNoSize("Connection: keep-alive, Upgrade\r\n");
	output.appendWithNoSize("Pragma: no-cache\r\n");
	output.appendWithNoSize("Cache-Control: no-cache\r\n");
	output.appendWithNoSize("Upgrade: websocket\r\n");
	output.appendWithNoSize("Origin: http://localhost:8080\r\n");
	output.appendWithNoSize("Sec-WebSocket-Version: 13\r\n");
	output.appendWithNoSize("User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36\r\n");
	output.appendWithNoSize("Accept-Encoding: gzip, deflate, sdch\r\n");
	output.appendWithNoSize("Accept-Language: en-US,en;q=0.8\r\n");
	output.appendWithNoSize("Cookie: GameServer=CJP5G89v2O30Dx-StfclobgZ0AuIH8Nh74SEzHxvBJEZWG6yJ3smhW73TZgDMO0HEy8AvYhKgzxVry5Yby75oT-250dW6PTdm74rhmQyACSwbiAbvp67108QZid7KoPJjf-OuP1cf5Z31_eHimsW8JTIf9KINfG0yy31WuDb21XU-nH9EJcVKhdoXrQB_35DPIRymBxV85cENsxScjjMIBnI60mUR1koC5k_XcwSiTgnoT9ApEPwIX6Z9iw0tV2X7\r\n");
	output.appendWithNoSize("Sec-WebSocket-Key: +40NMxLMogWjfV/0HyjlxA==\r\n");
	output.appendWithNoSize("Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n");
	output.appendWithNoSize("Sec-WebSocket-Protocol: 05fcc56b7cb916d5e5a82081223b3357\r\n\r\n");
	return output;
}

// creates a correct response header for the request generated by createTestHandshakeRequestHeader()
ByteArray createTestResponseHandshakeHeader(){
	ByteArray output;

	output.appendWithNoSize("HTTP/1.1 101 Switching Protocols\r\n");
	output.appendWithNoSize("Upgrade: websocket\r\n");
	output.appendWithNoSize("Connection: Upgrade\r\n");
	output.appendWithNoSize("Sec-WebSocket-Accept: XvS4xrxcXUWz3C5CU/McPLRYBFY=\r\n");
	output.appendWithNoSize("Sec-WebSocket-Protocol: 05fcc56b7cb916d5e5a82081223b3357\r\n\r\n");

	return output;
}

// creates a WebsocketAuthenticator that accepts all connections and uses a mock implementation of network system calls
class AuthenticatorTestFactory{
public:
	MockSystemWrapperState &systemWrap;
	WebsocketAuthenticator WA;


	class MyClientValidator : public ClientValidatorInterface
	{
	public:

		bool areClientHeadersValid(ConnectionHeaders &headers) override
		{
			(void)headers;
			//accept all connections
			return true;
		}
		bool isClientIPValid(std::string &ip, std::string &port) override
		{
			(void)ip;
			(void)port;
			//accept all connections
			return true;
		}
		~MyClientValidator() override = default;
	};

	MyClientValidator validator;
	AuthenticatorTestFactory(SetOfFileDescriptors*FDs ):
		systemWrap(MockSystemWrapperState::getMockSystemInstance(true)), WA(FDs)
	{
		WA.setClientValidator(&validator);
	}
};


TEST(WebsocketAuthenticatorTest, WebsocketAuthenticator)
{
	SetOfFileDescriptors FDs;
	ASSERT_THROW(WebsocketAuthenticator  failed(nullptr), std::runtime_error);
	WebsocketAuthenticator authenticator(&FDs);
}

TEST(WebsocketAuthenticatorTest, processHandshake)
{
	SetOfFileDescriptors FDs;
	FDs.addFD(1);
	AuthenticatorTestFactory authenticator(&FDs);

	// test with too much data
	ByteArray testString = createTestHandshakeRequestHeader();
	testString.appendWithNoSize(generateTestString(2049));
	ASSERT_THROW(authenticator.WA.processHandshake(testString,1), std::runtime_error);

	// test with wrong request type
	ByteArray validHeader = createTestHandshakeRequestHeader();
	testString = ByteArray();
	testString.appendWithNoSize("POST ");
	testString.resize(validHeader.size() + 1);
	memcpy(&testString[5],&validHeader[4], validHeader.size() - 4);
	ASSERT_THROW(authenticator.WA.processHandshake(testString,1), std::runtime_error);

	// test with garbage data
	testString = ByteArray();
	testString.appendWithNoSize("GET ");
	testString.appendWithNoSize(generateTestString(50));
	testString.appendWithNoSize("\r\n\r\n");
	ASSERT_THROW(authenticator.WA.processHandshake(testString,1), std::runtime_error);

	// test with data split in two
	ByteArray validHeaderPart1(5);
	memcpy(&validHeaderPart1[0], &validHeader[0], 5);
	ByteArray validHeaderPart2(validHeader.size()-5);
	memcpy(&validHeaderPart2[0], &validHeader[5], validHeader.size()-5);
	EXPECT_NO_THROW(authenticator.WA.processHandshake(validHeaderPart1,1));
	EXPECT_NO_THROW(authenticator.WA.processHandshake(validHeaderPart2,1));

	// test with correct data
	EXPECT_NO_THROW(authenticator.WA.processHandshake(validHeader,1));
}

TEST(WebsocketAuthenticatorTest, sendHandshake)
{
	SetOfFileDescriptors FDs;
	AuthenticatorTestFactory authenticator(&FDs);
	FDs.addFD(1);

	ByteArray validHeader = createTestHandshakeRequestHeader();
	authenticator.WA.processHandshake(validHeader,1);

	// set the system to simulate a full buffer on socket 1 after 10 bytes are written
	authenticator.systemWrap.setBytesTillWriteFail(1, 10);
	// should return false with partial write
	EXPECT_EQ(false, authenticator.WA.sendHandshake(1));
	EXPECT_EQ(false, authenticator.WA.sendHandshake(1));

	// set system to allow all bytes to be written
	authenticator.systemWrap.setBytesTillWriteFail(1, -1);
	// should return true after writing all bytes
	EXPECT_EQ(true, authenticator.WA.sendHandshake(1));

	// get the written data from the system
	std::string data = authenticator.systemWrap.getWriteBuffer(1);

	// check the data to make sure it is correct
	std::string expected = createTestResponseHandshakeHeader().toString();
	EXPECT_STREQ( data.c_str(), expected.c_str());
}

TEST(WebsocketAuthenticatorTest, closeFD)
{
	SetOfFileDescriptors FDs;
	AuthenticatorTestFactory authenticator(&FDs);
	FDs.addFD(1);

	ByteArray validHeader = createTestHandshakeRequestHeader();

	// split validHeader into two parts
	ByteArray validHeaderPart1(5);
	memcpy(&validHeaderPart1[0], &validHeader[0], 5);
	ByteArray validHeaderPart2(validHeader.size()-5);
	memcpy(&validHeaderPart2[0], &validHeader[5], validHeader.size()-5);

	// fill write buffer
	authenticator.WA.processHandshake(validHeader,1);
	// partial fill the read buffer
	authenticator.WA.processHandshake(validHeaderPart1,1);

	// should erase the write and read buffers of FD 1
	authenticator.WA.closeFD(1);

	// should throw because we erased the first half when the read buffer was erased
	ASSERT_THROW(authenticator.WA.processHandshake(validHeaderPart2,1);, std::runtime_error);

	// should throw when called without a write buffer
	ASSERT_THROW(authenticator.WA.sendHandshake(1), std::runtime_error);
}

// A Validator that should fail validation if the client's IP address is "IPFail" or their port is "PortFail"
// or Origin is "OriginFail" or the header SecWebSocketProtocol is "SecFail" or the header cookie is "CookieFail"

class TestClientValidator : public ClientValidatorInterface
{
public:
	bool areClientHeadersValid(ConnectionHeaders &headers) override
	{
		if(headers.origin.compare("OriginFail") == 0) {
			return false;
		}
		if(headers.ip.compare("IPFail") == 0) {
			return false;
		}
		if(headers.port.compare("PortFail") == 0) {
			return false;
		}
		if(headers.secWebSocketProtocol.compare("SecFail") == 0) {
			return false;
		}
		if(headers.cookie.compare("CookieFail") == 0) {
			return false;
		}

		return true;
	}
	bool isClientIPValid(std::string &ip, std::string &port) override
	{
		if(ip.compare("IPFail") == 0) {
			return false;
		}
		if(port.compare("PortFail") == 0) {
			return false;
		}
		//accept all traffic
		return true;
	}
	~TestClientValidator() override = default;
};

// creates a websocket handshake request header
ByteArray createAHandshakeRequestHeader(const std::string origin, const std::string secWebSocketProtocol, const std::string cookie){
	ByteArray output;

	output.appendWithNoSize("GET /socket HTTP/1.1\r\n");
	output.appendWithNoSize("Host: localhost\r\n");
	output.appendWithNoSize("Connection: keep-alive, Upgrade\r\n");
	output.appendWithNoSize("Pragma: no-cache\r\n");
	output.appendWithNoSize("Cache-Control: no-cache\r\n");
	output.appendWithNoSize("Upgrade: websocket\r\n");
	output.appendWithNoSize(std::string("Origin: ") + origin + "\r\n" );
	output.appendWithNoSize("Sec-WebSocket-Version: 13\r\n");
	output.appendWithNoSize("User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36\r\n");
	output.appendWithNoSize("Accept-Encoding: gzip, deflate, sdch\r\n");
	output.appendWithNoSize("Accept-Language: en-US,en;q=0.8\r\n");
	output.appendWithNoSize(std::string("Cookie: GameServer=") + cookie + "\r\n");
	output.appendWithNoSize("Sec-WebSocket-Key: +40NMxLMogWjfV/0HyjlxA==\r\n");
	output.appendWithNoSize("Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n");
	output.appendWithNoSize(std::string("Sec-WebSocket-Protocol: ") + secWebSocketProtocol + "\r\n\r\n" );
	return output;
}

TEST(WebsocketAuthenticatorTest, isNotValidConnection)
{
	TestClientValidator validator;

	SetOfFileDescriptors FDs;
	AuthenticatorTestFactory authenticator(&FDs);
	FDs.addFD(1);

	authenticator.WA.setClientValidator(&validator);

	ByteArray badOrigin = createAHandshakeRequestHeader("OriginFail", "05fcc56b7cb916d5e5a82081223b3357", "GameServer=CJP5G89v2O30Dx-StfclobgZ0AuIH8Nh74SEzHxvBJEZWG6yJ3smhW73TZgDMO0HEy8AvYhKgzxVry5Yby75oT-250dW6PTdm74rhmQyACSwbiAbvp67108QZid7KoPJjf-OuP1cf5Z31_eHimsW8JTIf9KINfG0yy31WuDb21XU-nH9EJcVKhdoXrQB_35DPIRymBxV85cENsxScjjMIBnI60mUR1koC5k_XcwSiTgnoT9ApEPwIX6Z9iw0tV2X7");
	ByteArray badCookie = createAHandshakeRequestHeader("http://localhost:8080", "05fcc56b7cb916d5e5a82081223b3357", "CookieFail");
	ByteArray badSec = createAHandshakeRequestHeader("http://localhost:8080", "SecFail", "GameServer=CJP5G89v2O30Dx-StfclobgZ0AuIH8Nh74SEzHxvBJEZWG6yJ3smhW73TZgDMO0HEy8AvYhKgzxVry5Yby75oT-250dW6PTdm74rhmQyACSwbiAbvp67108QZid7KoPJjf-OuP1cf5Z31_eHimsW8JTIf9KINfG0yy31WuDb21XU-nH9EJcVKhdoXrQB_35DPIRymBxV85cENsxScjjMIBnI60mUR1koC5k_XcwSiTgnoT9ApEPwIX6Z9iw0tV2X7");
	ASSERT_THROW(authenticator.WA.processHandshake(badOrigin,1);, std::runtime_error);
	ASSERT_THROW(authenticator.WA.processHandshake(badCookie,1);, std::runtime_error);
	ASSERT_THROW(authenticator.WA.processHandshake(badSec,1);, std::runtime_error);

	ByteArray goodHeader = createTestHandshakeRequestHeader();
	EXPECT_NO_THROW(authenticator.WA.processHandshake(goodHeader,1));

	ByteArray badIP("IPFail");
	FDs.setIP(1, badIP);
	ASSERT_THROW(authenticator.WA.processHandshake(goodHeader,1);, std::runtime_error);
	ByteArray goodIP("192.168.0.0");
	FDs.setIP(1, goodIP);

	ByteArray badPort("PortFail");
	FDs.setPort(1, badPort);
	ASSERT_THROW(authenticator.WA.processHandshake(goodHeader,1);, std::runtime_error);
	ByteArray goodPort("53256");
	FDs.setPort(1, goodPort);

	EXPECT_EQ(true,authenticator.WA.isNotValidConnection(ByteArray("IPFail"), ByteArray("port")));
	EXPECT_EQ(true,authenticator.WA.isNotValidConnection(ByteArray("IP"), ByteArray("PortFail")));
	EXPECT_EQ(false,authenticator.WA.isNotValidConnection(ByteArray("IP"), ByteArray("port")));
}

int main(int argc, char *argv[])
{
	::testing::InitGoogleTest(&argc, argv);
	StaySilentOnSuccess();
	return RUN_ALL_TESTS();
}
